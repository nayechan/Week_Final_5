#!/usr/bin/env python3
"""
Mundi Engine - Lua ë°”ì¸ë”© ìë™ ìƒì„± ë„êµ¬

UPROPERTYì™€ UFUNCTION ë§¤í¬ë¡œë¥¼ íŒŒì‹±í•˜ì—¬
.generated.cpp íŒŒì¼ì„ ìë™ ìƒì„±í•©ë‹ˆë‹¤.

ì‚¬ìš©ë²•:
    python generate.py --source-dir <ì†ŒìŠ¤ ë””ë ‰í† ë¦¬> --output-dir <ì¶œë ¥ ë””ë ‰í† ë¦¬>
"""

import argparse
import sys
from pathlib import Path
from parser import HeaderParser
from property_generator import PropertyGenerator
from lua_generator import LuaBindingGenerator


GENERATED_HEADER_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#pragma once

// Macro expansion for GENERATED_REFLECTION_BODY()
// This file must be included BEFORE the class definition
#define CURRENT_CLASS_GENERATED_BODY \\
public: \\
    using Super = {parent_class}; \\
    using ThisClass_t = {class_name}; \\
    static UClass* StaticClass() \\
    {{ \\
        static UClass Cls{{ "{class_name}", {parent_class}::StaticClass(), sizeof({class_name}) }}; \\
        static bool bRegistered = (UClass::SignUpClass(&Cls), true); \\
        return &Cls; \\
    }} \\
    virtual UClass* GetClass() const override {{ return {class_name}::StaticClass(); }} \\
    {class_name}(const {class_name}&) = default; \\
    {class_name}* Duplicate() const override \\
    {{ \\
        {class_name}* NewObject = ObjectFactory::DuplicateObject<{class_name}>(this); \\
        NewObject->DuplicateSubObjects(); \\
        NewObject->PostDuplicate(); \\
        return NewObject; \\
    }} \\
private: \\
    static void StaticRegisterProperties(); \\
    static const bool bPropertiesRegistered; \\
public:
"""

GENERATED_CPP_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#include "pch.h"
#include "{header_include}"
#include "Source/Runtime/Core/Object/ObjectMacros.h"
#include "Source/Runtime/Engine/Scripting/LuaBindHelpers.h"

// ===== Class Factory Registration (IMPLEMENT_CLASS) =====
{implement_class_code}

// ===== Property Reflection =====
{property_code}

// ===== Lua Binding =====
{lua_code}
"""


def write_file_if_different(file_path: Path, new_content: str) -> bool:
    """
    íŒŒì¼ ë‚´ìš©ì´ ì‹¤ì œë¡œ ë‹¤ë¥¼ ë•Œë§Œ íŒŒì¼ì„ ì”ë‹ˆë‹¤.
    íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ìœ ì§€í•˜ì—¬ ë¶ˆí•„ìš”í•œ ì¬ì»´íŒŒì¼ì„ ë°©ì§€í•©ë‹ˆë‹¤.

    Returns:
        True if file was written, False if content was identical
    """
    # íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ê³  ë‚´ìš©ì´ ê°™ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
    if file_path.exists():
        existing_content = file_path.read_text(encoding='utf-8')
        if existing_content == new_content:
            return False

    # ë‚´ìš©ì´ ë‹¤ë¥´ê±°ë‚˜ íŒŒì¼ì´ ì—†ìœ¼ë©´ ì“°ê¸°
    file_path.write_text(new_content, encoding='utf-8')
    return True


def generate_header_file(class_info):
    """.generated.h íŒŒì¼ ìƒì„±"""
    return GENERATED_HEADER_TEMPLATE.format(
        class_name=class_info.name,
        parent_class=class_info.parent
    )


def generate_implement_class(class_info):
    """IMPLEMENT_CLASS ë§¤í¬ë¡œ í™•ì¥ ì½”ë“œ ìƒì„±"""
    class_name = class_info.name
    return f"""
// IMPLEMENT_CLASS({class_name}) expansion
namespace {{
    struct {class_name}FactoryRegister
    {{
        {class_name}FactoryRegister()
        {{
            ObjectFactory::RegisterClassType(
                {class_name}::StaticClass(),
                []() -> UObject* {{ return new {class_name}(); }}
            );
        }}
    }};
    static {class_name}FactoryRegister GRegister_{class_name};
    static bool bIsRegistered_{class_name} = [](){{ {class_name}::StaticClass(); return true; }}();
}}

// Static member initialization for reflection registration
const bool {class_name}::bPropertiesRegistered = []() {{
    {class_name}::StaticRegisterProperties();
    return true;
}}();
"""


def generate_cpp_file(class_info, prop_gen, lua_gen):
    """.generated.cpp íŒŒì¼ ìƒì„±"""
    # í—¤ë” íŒŒì¼ ìƒëŒ€ ê²½ë¡œ ê³„ì‚°
    header_include = class_info.header_file.name

    # IMPLEMENT_CLASS ì½”ë“œ ìƒì„±
    implement_class_code = generate_implement_class(class_info)

    # í”„ë¡œí¼í‹° ì½”ë“œ ìƒì„±
    property_code = prop_gen.generate(class_info)

    # Lua ë°”ì¸ë”© ì½”ë“œ ìƒì„±
    lua_code = lua_gen.generate(class_info)

    # ìµœì¢… íŒŒì¼ ë‚´ìš©
    return GENERATED_CPP_TEMPLATE.format(
        header_include=header_include,
        implement_class_code=implement_class_code,
        property_code=property_code,
        lua_code=lua_code
    )


def main():
    parser = argparse.ArgumentParser(
        description='Mundi Engine Lua Binding Auto-Generator'
    )
    parser.add_argument(
        '--source-dir',
        type=Path,
        required=True,
        help='ì†ŒìŠ¤ ë””ë ‰í† ë¦¬ ê²½ë¡œ (ì˜ˆ: Source/Runtime)'
    )
    parser.add_argument(
        '--output-dir',
        type=Path,
        required=True,
        help='ìƒì„±ëœ íŒŒì¼ ì¶œë ¥ ë””ë ‰í† ë¦¬ (ì˜ˆ: Build/Generated)'
    )

    args = parser.parse_args()

    # ë””ë ‰í† ë¦¬ ì¡´ì¬ í™•ì¸
    if not args.source_dir.exists():
        print(f"âŒ Error: Source directory not found: {args.source_dir}")
        sys.exit(1)

    # ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
    args.output_dir.mkdir(parents=True, exist_ok=True)

    print("=" * 60)
    print("ğŸ”¨ Mundi Engine - Code Generator")
    print("=" * 60)
    print(f"ğŸ“ Source: {args.source_dir}")
    print(f"ğŸ“ Output: {args.output_dir}")
    print()

    # íŒŒì„œ ì´ˆê¸°í™”
    header_parser = HeaderParser()
    prop_gen = PropertyGenerator()
    lua_gen = LuaBindingGenerator()

    # í—¤ë” íŒŒì¼ ìŠ¤ìº”
    print("ğŸ” Scanning for reflection classes...")
    classes = header_parser.find_reflection_classes(args.source_dir)

    if not classes:
        print("âš ï¸  No classes with GENERATED_REFLECTION_BODY() found.")
        return

    print(f"\nâœ… Found {len(classes)} reflection class(es)\n")

    # ê° í´ë˜ìŠ¤ì— ëŒ€í•´ .generated.hì™€ .generated.cpp ìƒì„±
    generated_files = []
    updated_count = 0
    skipped_count = 0

    for class_info in classes:
        # .generated.h íŒŒì¼ ìƒì„±
        header_output = args.output_dir / f"{class_info.name}.generated.h"
        header_code = generate_header_file(class_info)
        header_updated = write_file_if_different(header_output, header_code)
        if header_updated:
            updated_count += 1
        generated_files.append(header_output)

        # .generated.cpp íŒŒì¼ ìƒì„±
        cpp_output = args.output_dir / f"{class_info.name}.generated.cpp"
        cpp_code = generate_cpp_file(class_info, prop_gen, lua_gen)
        cpp_updated = write_file_if_different(cpp_output, cpp_code)
        if cpp_updated:
            updated_count += 1
        generated_files.append(cpp_output)

        # ìƒíƒœ í‘œì‹œ
        if header_updated or cpp_updated:
            status = "âœ“ Updated"
        else:
            status = "â­ï¸  Skipped (no changes)"
            skipped_count += 1

        print(f"{status}: {class_info.name}")
        if header_updated:
            print(f"  â”œâ”€ {header_output.name} (modified)")
        if cpp_updated:
            print(f"  â”œâ”€ {cpp_output.name} (modified)")
        print(f"  â”œâ”€ Properties: {len(class_info.properties)}")
        print(f"  â””â”€ Functions:  {len([f for f in class_info.functions if f.metadata.get('lua_bind')])}")

    print()
    print("=" * 60)
    print(f"âœ… Code generation complete!")
    print(f"   Total files: {len(generated_files)}")
    print(f"   Updated: {updated_count}")
    print(f"   Skipped: {skipped_count * 2} (unchanged)")
    print("=" * 60)


if __name__ == '__main__':
    main()
