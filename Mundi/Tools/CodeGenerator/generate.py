#!/usr/bin/env python3
"""
Mundi Engine - Lua ë°”ì¸ë”© ìë™ ìƒì„± ë„êµ¬

UPROPERTYì™€ UFUNCTION ë§¤í¬ë¡œë¥¼ íŒŒì‹±í•˜ì—¬
.generated.cpp íŒŒì¼ì„ ìë™ ìƒì„±í•©ë‹ˆë‹¤.

ì‚¬ìš©ë²•:
    python generate.py --source-dir <ì†ŒìŠ¤ ë””ë ‰í† ë¦¬> --output-dir <ì¶œë ¥ ë””ë ‰í† ë¦¬>
"""

import argparse
import sys
from pathlib import Path
from parser import HeaderParser
from property_generator import PropertyGenerator
from lua_generator import LuaBindingGenerator


GENERATED_HEADER_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#pragma once

// Macro expansion for GENERATED_REFLECTION_BODY()
// This file must be included BEFORE the class definition
#define CURRENT_CLASS_GENERATED_BODY \\
public: \\
    /* DECLARE_CLASS functionality */ \\
    using Super = {parent_class}; \\
    using ThisClass_t = {class_name}; \\
    static UClass* StaticClass() \\
    {{ \\
        static UClass Cls{{ "{class_name}", {parent_class}::StaticClass(), sizeof({class_name}) }}; \\
        static bool bRegistered = []() {{ \\
            UClass::SignUpClass(&Cls); \\
            return true; \\
        }}(); \\
        return &Cls; \\
    }} \\
    virtual UClass* GetClass() const override {{ return {class_name}::StaticClass(); }} \\
    \\
    /* DECLARE_DUPLICATE functionality */ \\
    {class_name}(const {class_name}&) = default; \\
    {class_name}* Duplicate() const override \\
    {{ \\
        {class_name}* NewObject = ObjectFactory::DuplicateObject<{class_name}>(this); \\
        NewObject->DuplicateSubObjects(); \\
        NewObject->PostDuplicate(); \\
        return NewObject; \\
    }} \\
    \\
    /* Reflection registration */ \\
private: \\
    static void StaticRegisterProperties(); \\
    static const bool bPropertiesRegistered; \\
public:
"""

GENERATED_CPP_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#include "pch.h"
#include "{header_include}"
#include "Source/Runtime/Core/Object/ObjectMacros.h"
#include "Source/Runtime/Engine/Scripting/LuaBindHelpers.h"

// ===== Class Factory Registration (IMPLEMENT_CLASS) =====
{implement_class_code}

// ===== Property Reflection =====
{property_code}

// ===== Lua Binding =====
{lua_code}
"""


def generate_header_file(class_info):
    """.generated.h íŒŒì¼ ìƒì„±"""
    return GENERATED_HEADER_TEMPLATE.format(
        class_name=class_info.name,
        parent_class=class_info.parent
    )


def generate_implement_class(class_info):
    """IMPLEMENT_CLASS ë§¤í¬ë¡œ í™•ì¥ ì½”ë“œ ìƒì„±"""
    class_name = class_info.name
    return f"""
// IMPLEMENT_CLASS({class_name}) expansion
namespace {{
    struct {class_name}FactoryRegister
    {{
        {class_name}FactoryRegister()
        {{
            ObjectFactory::RegisterClassType(
                {class_name}::StaticClass(),
                []() -> UObject* {{ return new {class_name}(); }}
            );
        }}
    }};
    static {class_name}FactoryRegister GRegister_{class_name};
    static bool bIsRegistered_{class_name} = [](){{ {class_name}::StaticClass(); return true; }}();
}}

// Static member initialization for reflection registration
const bool {class_name}::bPropertiesRegistered = []() {{
    {class_name}::StaticRegisterProperties();
    return true;
}}();
"""


def generate_cpp_file(class_info, prop_gen, lua_gen):
    """.generated.cpp íŒŒì¼ ìƒì„±"""
    # í—¤ë” íŒŒì¼ ìƒëŒ€ ê²½ë¡œ ê³„ì‚°
    header_include = class_info.header_file.name

    # IMPLEMENT_CLASS ì½”ë“œ ìƒì„±
    implement_class_code = generate_implement_class(class_info)

    # í”„ë¡œí¼í‹° ì½”ë“œ ìƒì„±
    property_code = prop_gen.generate(class_info)

    # Lua ë°”ì¸ë”© ì½”ë“œ ìƒì„±
    lua_code = lua_gen.generate(class_info)

    # ìµœì¢… íŒŒì¼ ë‚´ìš©
    return GENERATED_CPP_TEMPLATE.format(
        header_include=header_include,
        implement_class_code=implement_class_code,
        property_code=property_code,
        lua_code=lua_code
    )


def main():
    parser = argparse.ArgumentParser(
        description='Mundi Engine Lua Binding Auto-Generator'
    )
    parser.add_argument(
        '--source-dir',
        type=Path,
        required=True,
        help='ì†ŒìŠ¤ ë””ë ‰í† ë¦¬ ê²½ë¡œ (ì˜ˆ: Source/Runtime)'
    )
    parser.add_argument(
        '--output-dir',
        type=Path,
        required=True,
        help='ìƒì„±ëœ íŒŒì¼ ì¶œë ¥ ë””ë ‰í† ë¦¬ (ì˜ˆ: Build/Generated)'
    )

    args = parser.parse_args()

    # ë””ë ‰í† ë¦¬ ì¡´ì¬ í™•ì¸
    if not args.source_dir.exists():
        print(f"âŒ Error: Source directory not found: {args.source_dir}")
        sys.exit(1)

    # ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
    args.output_dir.mkdir(parents=True, exist_ok=True)

    print("=" * 60)
    print("ğŸ”¨ Mundi Engine - Code Generator")
    print("=" * 60)
    print(f"ğŸ“ Source: {args.source_dir}")
    print(f"ğŸ“ Output: {args.output_dir}")
    print()

    # íŒŒì„œ ì´ˆê¸°í™”
    header_parser = HeaderParser()
    prop_gen = PropertyGenerator()
    lua_gen = LuaBindingGenerator()

    # í—¤ë” íŒŒì¼ ìŠ¤ìº”
    print("ğŸ” Scanning for reflection classes...")
    classes = header_parser.find_reflection_classes(args.source_dir)

    if not classes:
        print("âš ï¸  No classes with GENERATED_REFLECTION_BODY() found.")
        return

    print(f"\nâœ… Found {len(classes)} reflection class(es)\n")

    # ê° í´ë˜ìŠ¤ì— ëŒ€í•´ .generated.hì™€ .generated.cpp ìƒì„±
    generated_files = []
    for class_info in classes:
        # .generated.h íŒŒì¼ ìƒì„±
        header_output = args.output_dir / f"{class_info.name}.generated.h"
        header_code = generate_header_file(class_info)
        header_output.write_text(header_code, encoding='utf-8')
        generated_files.append(header_output)

        # .generated.cpp íŒŒì¼ ìƒì„±
        cpp_output = args.output_dir / f"{class_info.name}.generated.cpp"
        cpp_code = generate_cpp_file(class_info, prop_gen, lua_gen)
        cpp_output.write_text(cpp_code, encoding='utf-8')
        generated_files.append(cpp_output)

        print(f"âœ“ Generated: {class_info.name}")
        print(f"  â”œâ”€ {header_output.name}")
        print(f"  â”œâ”€ {cpp_output.name}")
        print(f"  â”œâ”€ Properties: {len(class_info.properties)}")
        print(f"  â””â”€ Functions:  {len([f for f in class_info.functions if f.metadata.get('lua_bind')])}")

    print()
    print("=" * 60)
    print(f"âœ… Code generation complete! ({len(generated_files)} files)")
    print("=" * 60)


if __name__ == '__main__':
    main()
